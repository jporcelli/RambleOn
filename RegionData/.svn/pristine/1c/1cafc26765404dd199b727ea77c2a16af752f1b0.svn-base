package regiondata;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import xml_utilities.XMLUtilities;
import static regiondata.RegionIOSettings.*;

/**
 * This class serves as a plug-in for reading region data from
 * XML files using the RegionDataSchema.XSD. As currently provided
 * this class does not cover output to XML files because the target 
 * application of this plug in does not require that behavior.
 *
 * @author James C. Porcelli, SBU ID # 108900819
 */
public class RegionIO implements RegionImporter {
    
    // THIS WILL HELP US PARSE THE XML FILES
    private XMLUtilities xmlUtil;
    // THIS IS THE SCHEMA WE'LL USE
    private File regionDataSchema;

    /**
     * Constructor for making our data importer. Note that it initializes
     * the XML utility for processing XML files and it sets up the schema for
     * use.
     */
    public RegionIO(File regionDataSchema) {
        xmlUtil = new XMLUtilities();

        // WE'LL USE THE SCHEMA FILE TO VALIDATE THE XML FILES
        this.regionDataSchema = regionDataSchema;
    }

    /**
     * Loads the region data from the specified XML region data file into the
     * regions manager.
     *
     * @param regionsFile The XML file to load the data from.
     *
     * @param regionsManager The manager which we will load the requested region
     * information from the XML file into.
     *
     * @return Returns true if the region data loads successfully, false otherwise.
     */
    @Override
    public boolean loadRegion(File regionDataFile, RegionDataManager regionsManager) {
        try {
            // FIRST LOAD ALL THE XML DATA INTO A DOM
            Document doc = xmlUtil.loadXMLDocument(regionDataFile.getAbsolutePath(),
                    regionDataSchema.getAbsolutePath());

            // LOAD ALL OF THE SUB REGIONS AND THEIR DATA
            loadRegionData(doc, regionsManager);

        } catch (Exception e) {
            //PRINT THE MESSAGE ASSOCIATED WITH THE EXCEPTION THAT WAS THROWN
            System.out.println("An error has occured while attempting to load the XML file");
            // XML FILE DIDN'T LOAD PROPERLY
            return false;
        }
        // XML FILE LOADED PROPERLY
        return true;
    }

    /**
     * Private helper method for loading region data. This method loads the
     * complete list of regions for the specified file which would be the parent
     * region, and then makes the appropriate call to the other helper methods
     * to load the other data associated with the current region, i.e flag images,
     * leader images, etc.
     *
     * @param doc The hierarchical region data loaded from an XML file into a
     * DOM, we'll extract the data from this doc and load it into the
     * regions manager.
     *
     * @param manager The data manager for all region and sub region data. We'll load
     * the data in the doc into this manager.
     */
    private void loadRegionData(Document doc, RegionDataManager manager) {
        // EMPTY THE SUB REGIONS LIST
        manager.clearRegions();
        //
        //UPON EMPTYING OF THE REGIONS LIST ALL REFERENCES TO THE REGIONS 
        //CONTAINED THEREIN WILL BE DESTROYED AND SO THE JVM WILL FREE THE
        //MEMORY ASSOCIATED WITH THOSE REGIONS THAT WERE CONTAINED INSIDE
        //EFFECTIVLY CLEARING THE ACTIVE REGION OBJECTS NO LONGER IN USE

        // FIRST GET THE PARENT REGION
        Node parentRegion = doc.getElementsByTagName(REGION_NODE).item(0);
        // AND THEN THE PARENT REGIONS ATTRIBUTES
        NamedNodeMap parentRegionAttributes = parentRegion.getAttributes();
        
        //GET THE PARENT REGION CAPITAL, IF IT EXISTS
        Node capitalNode = parentRegionAttributes.getNamedItem(CAPITAL_ATTRIBUTE);
        //THEN THE PARENT REGION LEADER, IF IT EXISTS
        Node leaderNode = parentRegionAttributes.getNamedItem(LEADER_ATTRIBUTE);
        //AND THEN THE NAME, ALL PARENT REGIOSN HAVE NAMES
        Node nameNode = parentRegionAttributes.getNamedItem(NAME_ATTRIBUTE);
        
        //LOAD THE MAP FOR THIS PARENT REGION       
        loadRegionMap(nameNode.getNodeValue(), manager);
        
        //PARENT REGION REGION OBJECT
        Region currentRegion;
        //IF PARENT REGION HAS NO CAPITAL AND NO LEADER THEN WE ARE LOADING THE WORLD OR A CONTINENT
        //
        //WORLD DOES NOT HAVE A GREY SCALE VALUE IN ANY CONTEXT, AND CONTINENT DOESNT IN THIS CONTEXT
        if (capitalNode == null && leaderNode == null) {
            //REGION IS THE WORLD OR CONTINENT
            //
            //CHECK WHICH BEFORE SETTING THE TYPE
            if (nameNode.getNodeValue().equals(THE_WORLD)) {
                //THIS MEANS WE ARE PLAYING THE CONTINENETS GAME
                currentRegion = new Region(nameNode.getNodeValue().toUpperCase(), nameNode.getNodeValue(), RegionType.WORLD);
            } else {
                //MUST BE A CONTINENT
                //
                //THIS MEANS WE ARE PLAYING A CONTINENET
                currentRegion = new Region(nameNode.getNodeValue().toUpperCase(), nameNode.getNodeValue(), RegionType.CONTINENT);
            }
        } else {
            //REGION IS A NATION
            //
            //PARENT REGIONS DONT HAVE A GREY SCALE VALUE IN THIS CONTEXT
            //THIS MEANS WE ARE PLAYING THE COUNTRY GAME
            currentRegion = new Region(nameNode.getNodeValue().toUpperCase(), nameNode.getNodeValue(),
                    RegionType.NATION, capitalNode.getNodeValue(), leaderNode.getNodeValue(), null);
        }

        //SET THIS REGION AS THE CURRENT REGION IN THE MANAGER
        manager.setCurrentRegion(currentRegion);

        // AND THEN GO THROUGH AND ADD ALL THE LISTED SUB REGIONS OF THE PARENT
        ArrayList<Node> regionsList = xmlUtil.getChildNodesWithName(parentRegion, SUB_REGION_NODE);
        for (int i = 0; i < regionsList.size(); i++) {
            // GET THEIR DATA FROM THE DOM
            //
            //WE WILL ITERATIVLY PROCESS EACH SUB REGION ELEMENT NODE
            Node regionNode = regionsList.get(i);
            
            //GET THE CURRENT NODES ATTRIBUTES
            NamedNodeMap regionAttributes = regionNode.getAttributes();
            
            //REQUIRED ATTRIBUTES
            //
            //SUB REGION NAME
            String name = regionAttributes.getNamedItem(NAME_ATTRIBUTE).getNodeValue();
            //SUB REGION BLUE VALUE
            String blue = regionAttributes.getNamedItem(BLUE_ATTRIBUTE).getNodeValue();
            //SUB REGION GREEN VALUE
            String green = regionAttributes.getNamedItem(GREEN_ATTRIBUTE).getNodeValue();
            //SUB REGION RED VALUE
            String red = regionAttributes.getNamedItem(RED_ATTRIBUTE).getNodeValue();

            //THE TYPE OF THIS SUB REGION
            RegionType regionType;
            //REGION OBJECT FOR THIS SUB REGION NODE
            Region regionToAdd;
            
            //THIS REGIONS GREY SCALE COLOR ON THE MAP
            Color greyScale = new Color(new Integer(blue), new Integer(green), new Integer(red));

            //OPTIONAL ATTRIBUTES (DEPENDS ON THE REGION TYPE)
            //
            //SUB REGION CAPITAL
            capitalNode = regionAttributes.getNamedItem(CAPITAL_ATTRIBUTE);
            //SUB REGION LEADER
            leaderNode = regionAttributes.getNamedItem(LEADER_ATTRIBUTE);
            
            //PROCESS THE SUB REGION NODE ACCORDING TO WHAT DATA WAS FOUND 
            if (capitalNode != null) {
                // ALL NATIONS AND STATES HAVE CAPITALS
                regionType = RegionType.STATE;
                regionToAdd = new Region(name.toUpperCase(), name, regionType,
                        capitalNode.getNodeValue(), leaderNode.getNodeValue(), greyScale);
            } else {
                // CONTINENTS DO NOT
                regionType = RegionType.CONTINENT;
                regionToAdd = new Region(name.toUpperCase(), name, regionType, null, null, greyScale);
            }
            
            //PUT THE REGION IN THE MANAGER
            manager.addRegion(regionToAdd);
            //AND ADD IT TO THE CURRENT REGIONS SUB REGIONS LIST
            currentRegion.addSubRegion(regionToAdd);

        }
    }

    /**
     * Load the map image for the current region. This map lays out all the
     * sub regions contained within the current region.
     * 
     * @param parentRegion The current region for which we want the map.
     * @param manager The region data manager where we will store the map image.
     */
    private void loadRegionMap(String parentRegion, RegionDataManager manager) {
        //THE MAP IMAGE
        BufferedImage currentRegionMap = null;
        try {
            //LOAD THE CURRENT PARENT REGIONS MAP
            currentRegionMap = ImageIO.read(new File(parentRegion + MAP_IMAGE));
        } catch (IOException e) {
            //HANDLE EXCEPTION DURING MAP IMAGE LOADING
            System.out.println("An error occured while attempting to load the current regions map");
            //EXIT 
            return;
        }
        //IF WERE HERE NO ERRORS OCCURED
        //
        //SO ADD THE MAP IMAGE TO THE DATA MANAGER
        manager.setCurrentMap(currentRegionMap);
    }
    
    /**
     * This method is called in an attempt to load leader images/information for
     * a particular region. If leader information is available for the sub regions
     * of the current region then those leader images are loaded into the data 
     * structure in the region data manager for storing leader images. If leader
     * information is not available a LeaderInformationNotAvailableException is 
     * thrown.
     * 
     * @throws LeaderInformationNotAvailableException When leader information is
     * not available for the current region.
     */
    public void loadRegionLeaderImages() throws LeaderInformationNotAvailableException{
        
    }
}
